embed {{ tex-preamble

\newcommand{\sur}[1]{\underline{#1} }
\newcommand{\alg}[1]{\widehat{#1} }
\newcommand{\suralg}[1]{\widehat{\underline{#1} } }

}}


metavar a {{ tex \alpha }}, b {{ tex \beta }}, g {{ tex \gamma }}, d {{tex \delta}}, 
 α {{ tex \alpha }}, β {{ tex \beta }},
 γ {{ tex \gamma }},  δ {{ tex \delta }} ::= {{ com type variables }}

indexvar n , m, i, j, k ::= {{ com index variables }}

metavar x, y   ::= {{ com term variable }}
metavar sx {{tex \underline{x} }}, sy {{tex \underline{y} }} ::= {{ com safe term variable }}

metavar ax {{tex \widehat{x} }}, ay {{tex \widehat{y} }}   ::= {{ com term algorithmic variable }}

grammar 

varx {{ tex x }}, vary {{ tex y }}  :: 'var_' ::=
  | x  ::   :: Var
  | sx ::   :: SVar

e {{ tex e }}, p {{ tex p }} :: 'e_' ::=
  | varx            ::   :: Var    % {{ com variable }}
                               % {{ com safe variable occurrences }}
  | <>           ::   :: Unit   % {{ com unit }}
  | λ x : A . e  ::   :: Lam    % {{ com lambda abstraction }}
  | λ̂ sx : A . e ::   :: PLam   % {{ com implicit lambda abstraction }}
  | e1 e2       ::   :: App    % {{ com application }}
  | e1 { e2 }   ::   :: PApp    % {{ com application }}
  | refl e      ::   :: Refl   % {{ com reflexivity }}
  | subst ( p : e1 = e2 : A , x . B , e ) ::   :: Subst    % {{ com subst eliminator }}
  | let varx : A = e1 in e2 ::   :: Let    % {{ com let binding }}
  | ax [ σ ]    ::   :: AVar   {{ tex [[ax]] [ [[σ]] ] }} % {{ com algorithmic variable }}
  | _           ::   :: Placeholder
  | ( e )       :: S :: Paren  % {{ com parentheses }}

A {{ tex A }}, B {{ tex B }}, C {{ tex C }}, D {{ tex D }}  :: 'A_' ::=
  | Unit            ::   :: UnitT   {{ tex 1 }}
  | Π x : A . B     ::   :: Pi      {{ tex \Pi [[x]]:[[A]] . \, [[B]] }}
  | ∀ sx : A . B    ::   :: Forall {{ tex \forall [[sx]]:[[A]] . \, [[B]] }}
  | e1 = e2 : A     ::   :: Eq      {{ tex [[e1]] = [[e2]] : [[A]] }}
  | let varx : A = e in B ::   :: Let    % {{ com let binding }}
  | ( A )           :: S :: Paren 

eAList :: 'eAList_' ::=
  | ·                   ::   :: Empty    
  | e                   ::   :: Term
  | A                   ::   :: Type
  | eAList1 , eAList2   ::   :: Concat   {{ com concatenate }}

ce {{ tex cE }}, cp {{ tex cP }} :: 'ce_' ::=
  | ●             ::   :: Place
  | λ x : cA . e ::   :: LamA
  | λ x : A . ce ::   :: LamE
  | λ̂ sx : cA . e ::   :: PLamA
  | λ̂ sx : A . ce ::   :: PLamE
  | ce1  e2       ::   :: CAppOne
  | e1 ce2        ::   :: CAppTwo
  | refl ce       ::   :: CRefl
  | subst ( cp : e1 = e2 : A , x . B , e ) ::   :: CSubstP
  | subst ( p : ce1 = e2 : A , x . B , e ) ::   :: CSubstEOne
  | subst ( p : e1 = ce2 : A , x . B , e ) ::   :: CSubstETwo
  | subst ( p : e1 = e2 : cA , x . B , e ) ::   :: CSubstA
  | subst ( p : e1 = e2 : A , x . cB , e ) ::   :: CSubstB
  | subst ( p : e1 = e2 : A , x . B , ce ) ::   :: CSubstE
  | let x = ce1 in e2 ::   :: LetEOne 
  | let x = e1 in ce2 ::   :: LetETwo
  | ( ce )       :: S :: Paren

cA {{ tex cA }}, cB {{ tex cB }} :: 'cA_' ::=
  | Π x : cA . B ::   :: PiA    {{ tex \Pi [[x]]:[[cA]] . \, [[B]] }}
  | Π x : A . cB ::   :: PiB    {{ tex \Pi [[x]]:[[A]] . \, [[cB]] }}
  | ∀ sx : cA . B ::   :: ForallA  {{ tex \forall [[sx]]:[[cA]] . \, [[B]] }}
  | ∀ sx : A . cB ::   :: ForallB {{ tex \forall [[sx]]:[[A]] . \, [[cB]] }}
  | ce1 = e2 : A ::   :: EqE1   {{ tex [[ce1]] = [[e2]] : [[A]] }}
  | e1 = ce2 : A ::   :: EqE2   {{ tex [[e1]] = [[ce2]] : [[A]] }}
  | e1 = e2 : cA ::   :: EqA    {{ tex [[e1]] = [[e2]] : [[cA]] }}
  | ( cA )       :: S :: Paren 
  

s {{ tex \sigma }}, σ {{ tex \sigma }}  :: 'Subst_' ::=
  | ·                   ::   :: Empty
  | varx ↦ vary               ::   :: Rename
  | s1 , s2             ::   :: Concat   {{ com concatenate }}


Vars {{ tex V }}  :: 'Vars_' ::=
  | ·                   ::   :: Empty    
  | varx                ::   :: Var
  | Vars1 , Vars2       ::   :: Concat   {{ com concatenate }}

G {{ tex \Gamma }}, Γ {{ tex \Gamma }} :: 'G_' ::= 
  | ·                   ::   :: Empty    
  | varx : A              ::   :: Var
  | Γ1 , Γ2             ::   :: Concat   {{ com concatenate }}

Mentr :: 'Mentr_' ::=
  | Γ ⊢ ax ⇐ A              ::   :: Chk
  | ( Mentr )               :: S :: Paren

% Meta context
MG {{ tex M\Gamma }}, MΓ {{ tex M\Gamma }} :: 'mG_' ::= 
    | ·                    ::   :: Empty 
    | Mentr                ::   :: Single
    | MG1 , MG2            ::   :: Concat   {{ com concatenate }}
    | ( MG )               :: S :: Paren  % {{ com parentheses }}

% Meta substitution
Ms {{ tex M\sigma }}, Mσ {{ tex M\sigma }}, Mτ {{ tex M\tau }} :: 'mSubst_' ::= 
    | ·                    ::   :: Empty 
    | ax ↦ e               ::   :: Subst
    | Ms1 , Ms2            ::   :: Concat   {{ com concatenate }}
    | ( Ms )               :: S :: Paren  % {{ com parentheses }}

terminals :: 'terminals_' ::=
  | ∃  :: :: exists    {{ tex \exists }}
  | .  :: :: dot       {{ tex .\, }}
  | ;  :: :: semi      {{ tex \mathbin{;} }}
  | ∀  :: :: forall    {{ tex \forall }}
  | ↑  :: :: upShift   {{ tex \mathord{\uparrow} }}
  | ↓  :: :: downShift {{ tex \mathord{\downarrow} }}
  | →  :: :: funArrow  {{ tex \rightarrow }}
  | ⤳  :: :: leadsto  {{ tex \leadsto }}
  | ↔  :: :: bijArrow  {{ tex \leftrightarrow }}
  | ∊  :: :: inSet     {{ tex \in }}
  | ∉  :: :: notInSet  {{ tex \notin }}
  | ·  :: :: cDot      {{ tex \cdot }}
  | ⊢  :: :: vdash     {{ tex \vdash }}
  | ≤  :: :: subtype   {{ tex \leqslant }}
  | ≥  :: :: supertype {{ tex \geqslant }}
  % | ≈  :: :: equiv     {{ tex \simeq }}
  | ∪  :: :: union     {{ tex \cup }}
  | ∩  :: :: intersect {{ tex \cap }}
  | \  :: :: setminus  {{ tex \setminus }}
  | ⊆  :: :: subset    {{ tex \subseteq }}
  | ↦  :: :: mapsto    {{ tex \mapsto }}
  | ≈u :: :: unify      {{ tex \overset{u}{\simeq} }}
  | ≈au :: :: antiunify {{ tex \overset{a}{\simeq} }}
  | ∅ :: :: empty      {{ tex \emptyset }}
  | ○ :: :: compose    {{ tex \circ }}
  | ⇒ :: :: implies    {{ tex \Rightarrow }}
  | ⇐ :: :: checks     {{ tex \Leftarrow }}
  | ⇔ :: :: synchecks     {{ tex \Leftrightarrow }}
  % | ≈a :: :: antiunify {{ tex \overset{g}{\simeq} }}
  | ⊨  :: :: vDash     {{ tex \vDash }}
  | ⫤  :: :: Dashv     {{ tex \Dashv }}
  % | ⊫  :: :: VDash     {{ tex \mathcolor{\ccolor}{\VDash} }}
  % | ⫥  :: :: DashV     {{ tex \mathcolor{\ccolor}{\DashV} }}
  | ≠  :: :: neq       {{ tex \neq }}
  | ≡  :: :: equiv     {{ tex \equiv }}
  | ∨  :: :: LUB       {{ tex \vee }}
  | ⇓ :: :: norm       {{ tex \Downarrow }}
  | :≥ :: :: solGeq    {{ tex \mathbin{:\geqslant} }}
  | :≤ :: :: solLeq    {{ tex \mathbin{:\leqslant} }}
  | :≈ :: :: solEq     {{ tex \mathbin{:\simeq} }}
  | Λ    :: :: bigLam    {{ tex \Lambda }}
  | λ    :: :: lam       {{ tex \lambda^{\Pi} }}
  | λ̂    :: :: lamhat    {{ tex \lambda^{\forall} }}
  | ●    :: :: bullet    {{ tex \bullet }}
  | ⇒>   :: :: spinInf   {{ tex \Rightarrow \hspace{-3pt} > }}
  | <=<  :: :: compM     {{ tex \mathord{< \hspace{-5.3pt} = \hspace{-4.2pt} <} }}
  | &    :: :: ampersand {{ tex \mathbin{\&} }}
  | ▷    :: :: triangle {{ tex \triangleright }}
  | ×    :: :: times     {{ tex \times }}
  | ⊑   :: :: subeq     {{ tex \sqsubseteq }}
  | >>  :: :: spinApp     {{ tex \mathbin{> \hspace{-3pt} >} }}
  | <>  :: :: Unit     {{ tex \mathbin{< >} }}
  | ⤳* :: :: leadstoStar     {{ tex \leadsto^* }}


funs
  F ::=
fun 
  ce [ e1 ] :: e :: ECtxtSubst 
by


fun
  fv e :: Vars :: eFV
by 

fun
  Mσ1 ○ Mσ2 :: Mσ :: MComp
by

fun 
  [ Mσ ] e' :: e :: Msubst
by 


fun 
  [ e2 / x ] e1  :: e :: tsubst 
by

fun 
  [ e2 / sx ] e1  :: e :: tssubst 
by


% fun 
%   [ ae / x ] aB :: aA :: aTsubst 
% by


% fun 
%   [ σ ] _ Γ aA1  :: aA :: aAsubst {{ tex [ [[σ]] ]_{[[Γ]]} [[aA1]] }}
% by

% fun
%   lift aΓ :: σ :: aliftG {{ tex [[aΓ]] }}
% by

% fun 
%   [ σ ] _ Γ ae1  :: ae :: aAsubst {{ tex \[ [[σ]] \]_{[[Γ]]} [[ae1]] }}
% by


% fun 
%   lift A  :: aA :: aliftT {{ tex [[A]] }}
% by

% fun 
%   lift ae  :: sae :: salift {{ tex [[ae]] }}
% by
