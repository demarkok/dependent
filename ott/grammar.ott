embed {{ tex-preamble

\newcommand{\sur}[1]{\underline{#1} }
\newcommand{\alg}[1]{\widehat{#1} }
\newcommand{\suralg}[1]{\widehat{\underline{#1} } }

}}


metavar a {{ tex \alpha }}, b {{ tex \beta }}, g {{ tex \gamma }}, d {{tex \delta}}, 
 α {{ tex \alpha }}, β {{ tex \beta }},
 γ {{ tex \gamma }},  δ {{ tex \delta }} ::= {{ com type variables }}

indexvar n , m, i, j, k ::= {{ com index variables }}

metavar x, y   ::= {{ com term variable }}
metavar ax {{tex \widehat{x} }}, ay {{tex \widehat{y} }}   ::= {{ com term algorithmic variable }}

grammar 

e {{ tex e }}, p {{ tex p }} :: 'e_' ::=
  | x            ::   :: Var    % {{ com variable }}
                               % {{ com safe variable occurrences }}
  | <>           ::   :: Unit   % {{ com unit }}
  | λ x : A . e  ::   :: Lam    % {{ com lambda abstraction }}
  | λ̂ x : A . e ::   :: PLam   % {{ com implicit lambda abstraction }}
  | e1 e2       ::   :: App    % {{ com application }}
  | e1 { e2 }   ::   :: PApp    % {{ com application }}
  | refl e      ::   :: Refl   % {{ com reflexivity }}
  | subst ( p : e1 = e2 : A , x . B , e ) ::   :: Subst    % {{ com subst eliminator }}
  | let x = e1 in e2 ::   :: Let    % {{ com let binding }}
  | ax [ σ ]    ::   :: AVar   {{ tex [[ax]] [ [[σ]] ] }} % {{ com algorithmic variable }}
  | _           ::   :: Placeholder
  | ( e )       :: S :: Paren  % {{ com parentheses }}

A {{ tex A }}, B {{ tex B }}, C {{ tex C }}, D {{ tex D }}  :: 'A_' ::=
  | Unit           ::   :: UnitT {{ tex 1 }}
  | Π x : A . B    ::   :: Pi    (+ bind x in B +) {{ tex \Pi [[x]]:[[A]] . \, [[B]] }}
  | ∀ x : A . B    ::   :: Forall (+ bind x in B +) {{ tex \forall [[x]]:[[A]] . \, [[B]] }}
  | e1 = e2 : A    ::   :: Eq    {{ tex [[e1]] = [[e2]] : [[A]] }}
  | let x = e in A ::   :: Let    % {{ com let binding }}
  | ( A )          :: S :: Paren 

ce, cp :: 'ce_' ::=
  | ●             ::   :: Place
  | λ x : cA . e ::   :: LamA
  | λ x : A . ce ::   :: LamE
  | λ̂ x : cA . e ::   :: PLamA
  | λ̂ x : A . ce ::   :: PLamE
  | ce1  e2       ::   :: CAppOne
  | e1 ce2        ::   :: CAppTwo
  | refl ce       ::   :: CRefl
  | subst ( cp : e1 = e2 : A , x . B , e ) ::   :: CSubstP
  | subst ( p : ce1 = e2 : A , x . B , e ) ::   :: CSubstEOne
  | subst ( p : e1 = ce2 : A , x . B , e ) ::   :: CSubstETwo
  | subst ( p : e1 = e2 : cA , x . B , e ) ::   :: CSubstA
  | subst ( p : e1 = e2 : A , x . cB , e ) ::   :: CSubstB
  | subst ( p : e1 = e2 : A , x . B , ce ) ::   :: CSubstE
  | let x = ce1 in e2 ::   :: LetEOne 
  | let x = e1 in ce2 ::   :: LetETwo
  | ( ce )       :: S :: Paren

cA {{ tex cA }}, cB {{ tex cB }} :: 'cA_' ::=
  | Π x : cA . B ::   :: PiA    {{ tex \Pi [[x]]:[[cA]] . \, [[B]] }}
  | Π x : A . cB ::   :: PiB    {{ tex \Pi [[x]]:[[A]] . \, [[cB]] }}
  | ∀ x : cA . B ::   :: ForallA  {{ tex \forall [[x]]:[[cA]] . \, [[B]] }}
  | ∀ x : A . cB ::   :: ForallB {{ tex \forall [[x]]:[[A]] . \, [[cB]] }}
  | ce1 = e2 : A ::   :: EqE1   {{ tex [[ce1]] = [[e2]] : [[A]] }}
  | e1 = ce2 : A ::   :: EqE2   {{ tex [[e1]] = [[ce2]] : [[A]] }}
  | e1 = e2 : cA ::   :: EqA    {{ tex [[e1]] = [[e2]] : [[cA]] }}
  | ( cA )       :: S :: Paren 
  

s {{ tex \sigma }}, σ {{ tex \sigma }}  :: 'Subst_' ::=
  | ·                   ::   :: Empty


Vars {{ tex V }}  :: 'Vars_' ::=
  | ·                   ::   :: Empty    
  | x                   ::   :: Var
  | Vars1 , Vars2       ::   :: Concat   {{ com concatenate }}

SVars {{ tex sV }} :: 'sVars_' ::=
  | ·                   ::   :: Empty    
  | x                  ::   :: SVar
  | SVars1 , SVars2     ::   :: Concat   {{ com concatenate }}

G {{ tex \Gamma }}, Γ {{ tex \Gamma }} :: 'G_' ::= 
  | ·                   ::   :: Empty    
  | x : A               ::   :: Var
  | sx : A              ::   :: SVar
  | Γ1 , Γ2             ::   :: Concat   {{ com concatenate }}

% Constraints
MG {{ tex M\Gamma }}, MΓ {{ tex M\Gamma }} :: 'mG_' ::= 
    | ·                    ::   :: Empty 
    | Γ ⊢ ax ⇐ A           ::   :: Chk
    | MG1 , MG2            ::   :: Concat   {{ com concatenate }}
    | ( MG )               :: S :: Paren  % {{ com parentheses }}


terminals :: 'terminals_' ::=
  | ∃  :: :: exists    {{ tex \exists }}
  | .  :: :: dot       {{ tex .\, }}
  | ;  :: :: semi      {{ tex \mathbin{;} }}
  | ∀  :: :: forall    {{ tex \forall }}
  | ↑  :: :: upShift   {{ tex \mathord{\uparrow} }}
  | ↓  :: :: downShift {{ tex \mathord{\downarrow} }}
  | →  :: :: funArrow  {{ tex \rightarrow }}
  | ⤳  :: :: leadsto  {{ tex \leadsto }}
  | ↔  :: :: bijArrow  {{ tex \leftrightarrow }}
  | ∊  :: :: inSet     {{ tex \in }}
  | ∉  :: :: notInSet  {{ tex \notin }}
  | ·  :: :: cDot      {{ tex \cdot }}
  | ⊢  :: :: vdash     {{ tex \vdash }}
  | ≤  :: :: subtype   {{ tex \leqslant }}
  | ≥  :: :: supertype {{ tex \geqslant }}
  % | ≈  :: :: equiv     {{ tex \simeq }}
  | ∪  :: :: union     {{ tex \cup }}
  | ∩  :: :: intersect {{ tex \cap }}
  | \  :: :: setminus  {{ tex \setminus }}
  | ⊆  :: :: subset    {{ tex \subseteq }}
  | ↦  :: :: mapsto    {{ tex \mapsto }}
  | ≈u :: :: unify      {{ tex \overset{u}{\simeq} }}
  | ≈au :: :: antiunify {{ tex \overset{a}{\simeq} }}
  | ∅ :: :: empty      {{ tex \emptyset }}
  | ○ :: :: compose    {{ tex \circ }}
  | ⇒ :: :: implies    {{ tex \Rightarrow }}
  | ⇐ :: :: checks     {{ tex \Leftarrow }}
  | ⇔ :: :: synchecks     {{ tex \Leftrightarrow }}
  % | ≈a :: :: antiunify {{ tex \overset{g}{\simeq} }}
  | ⊨  :: :: vDash     {{ tex \vDash }}
  | ⫤  :: :: Dashv     {{ tex \Dashv }}
  % | ⊫  :: :: VDash     {{ tex \mathcolor{\ccolor}{\VDash} }}
  % | ⫥  :: :: DashV     {{ tex \mathcolor{\ccolor}{\DashV} }}
  | ≠  :: :: neq       {{ tex \neq }}
  | ≡  :: :: equiv     {{ tex \equiv }}
  | ∨  :: :: LUB       {{ tex \vee }}
  | ⇓ :: :: norm       {{ tex \Downarrow }}
  | :≥ :: :: solGeq    {{ tex \mathbin{:\geqslant} }}
  | :≤ :: :: solLeq    {{ tex \mathbin{:\leqslant} }}
  | :≈ :: :: solEq     {{ tex \mathbin{:\simeq} }}
  | Λ    :: :: bigLam    {{ tex \Lambda }}
  | λ    :: :: lam       {{ tex \lambda^{\Pi} }}
  | λ̂    :: :: lamhat    {{ tex \lambda^{\forall} }}
  | ●    :: :: bullet    {{ tex \bullet }}
  | ⇒>   :: :: spinInf   {{ tex \Rightarrow \hspace{-3pt} > }}
  | <=<  :: :: compM     {{ tex \mathord{< \hspace{-5.3pt} = \hspace{-4.2pt} <} }}
  | &    :: :: ampersand {{ tex \mathbin{\&} }}
  | ▷    :: :: triangle {{ tex \triangleright }}
  | ×    :: :: times     {{ tex \times }}
  | ⊑   :: :: subeq     {{ tex \sqsubseteq }}
  | >>  :: :: spinApp     {{ tex \mathbin{> \hspace{-3pt} >} }}
  | <>  :: :: Unit     {{ tex \mathbin{< >} }}


% funs
%   F ::=
% fun 
%   [ e / x ] B  :: A :: Tsubst 
% by

% fun 
%   [ e2 / x ] e1  :: e :: tsubst 
% by


% fun 
%   [ ae / x ] aB :: aA :: aTsubst 
% by


% fun 
%   [ σ ] _ Γ aA1  :: aA :: aAsubst {{ tex [ [[σ]] ]_{[[Γ]]} [[aA1]] }}
% by

% fun
%   lift aΓ :: σ :: aliftG {{ tex [[aΓ]] }}
% by

% fun 
%   [ σ ] _ Γ ae1  :: ae :: aAsubst {{ tex \[ [[σ]] \]_{[[Γ]]} [[ae1]] }}
% by


% fun 
%   lift A  :: aA :: aliftT {{ tex [[A]] }}
% by

% fun 
%   lift ae  :: sae :: salift {{ tex [[ae]] }}
% by
