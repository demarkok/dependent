defns
  Red :: 'Red' ::=

  defn e1 ⤳ e2 :: :: Red :: 'Red' by


  % Variables


    A0 ⤳ A1  
    ------------------ :: LamA
    λx:A0.e ⤳ λx:A1.e


    e0 ⤳ e1
    ------------------- :: Lame
    λx:A.e0 ⤳ λx:A.e1


    A0 ⤳ A1 
    --------------------- :: PLamA
    λ̂sx:A0.e ⤳ λ̂sx:A1.e


    e0 ⤳ e1
    -------------------- :: PLame
    λ̂sx:A.e0 ⤳ λ̂sx:A.e1


    e0 ⤳ e1
    ------------------ :: Refl
    refl e0 ⤳ refl e1


    % Eliminators


    e0 ⤳ e1
    ------------------- :: App1
    e0 e ⤳ e1 e


    -------------------------------- :: AppLam
    (λx:A.e0) e ⤳ let x:A = e in e0


    ---------------------------------------- :: AppPLam
    (λ̂sx:A.e0){e} ⤳ let sx:A = e in e0


    p0 ⤳ p1
    ---------------------------------------------------- :: SubstP
    subst(p0:e1=e2:A, x.B, e) ⤳ subst(p1:e1=e2:A, x.B, e)


    e0 ⤳ e1
    --------------------------------------------------- :: SubstE1
    subst(p:e0=e2:A, x.B, e) ⤳ subst(p:e1=e2:A, x.B, e)


    e0 ⤳ e2
    --------------------------------------------------- :: SubstE2
    subst(p:e1=e0:A, x.B, e) ⤳ subst(p:e1=e2:A, x.B, e)


    A0 ⤳ A
    --------------------------------------------------- :: SubstA
    subst(p:e1=e2:A0, x.B, e) ⤳ subst(p:e1=e2:A, x.B, e)


    B0 ⤳ B
    --------------------------------------------------- :: SubstB
    subst(p:e1=e2:A, x.B0, e) ⤳ subst(p:e1=e2:A, x.B, e)


    e0 ⤳ e
    --------------------------------------------------- :: SubstE
    subst(p:e1=e2:A, x.B, e0) ⤳ subst(p:e1=e2:A, x.B, e)


    e0, e2, e2, A, B are ground
    ------------------------------------- :: SubstRed
    subst((refl e0):e1=e2:A, x.B, e) ⤳ e
    

    A0 ⤳ A  
    ----------------------------------------- :: LetA
    let varx:A0 = e in e0 ⤳ let varx:A = e in e0


    e0 ⤳ e1
    -------------------------------------- :: LetE1
    let varx:A = e0 in e ⤳ let varx:A = e1 in e2


    e0 ⤳ e2
    ----------------------------------------- :: LetE2
    let varx:A = e in e0  ⤳ let varx:A = e1 in e2


    ce is safe
    ------------------------------------------ :: LRedSafe
    let varx:A = e in ce[varx] ⤳ let varx:A = e in ce[e]


    e is neutral
    ------------------------------------------ :: LRedNeut
    let varx:A = e in ce[varx]  ⤳ let varx:A = e in ce[e]


    e is ground
    ------------------------------------------ :: LRedGr
    let varx:A = e in ce[varx]  ⤳ let varx:A = e in ce[e]


    varx ∉ fv e2    A, e1 are ground
    ------------------------------------- :: LNotin
    let varx:A = e1 in e2  ⤳ e2

  defn A1 ⤳ A2 :: :: TRed :: 'TRed' by

  defn e is neutral :: :: Neut :: 'Neut' by

  defn eAList are ground :: :: eAGround :: 'eAGr' by

  defn e is ground :: :: eGround :: 'eGr' by

  defn ce is safe :: :: ceSafe :: 'ceS' by

  defn e ⤳* e1 :: :: RedStar :: 'RedS' by
